{
  "name": "app.second.sample_install.frontend.data.react_components.main.login",
  "type": "types.second.default.react_component.js",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props)\n          this.state = {};\n          \n        }\n        handleSubmit = async () => {\n          console.log('Trying login2');\n          \n          // build grant request \n          // - TODO: more fine-grained \n          let grantObj = {\n            redirect: WINDOW.location.href,\n          }\n          \n          console.log('grantObj', grantObj);\n\n          let qs = encodeQueryData(grantObj);\n          \n          // // save username to localStorage (grab on return) \n          // // - TODO: fetch via stellar, ipfs \n          \n          // let username = this.state.username;\n          \n          \n          // localStorage.setItem('username', username);\n          \n          // // TODO: \n          // // - load URL via Stellar \n          // // - also store publicKey \n          // let zoneFile = await loadUsernameZonefile(username);\n          // if(!zoneFile){\n          //   WINDOW.alert('Unable to load username zone file!', username);\n          //   return false;\n          // }\n          \n          // // console.log('zoneFile:', zoneFile);\n          // // return false;\n          \n          // let authInfo = {\n          //   username, // identity, also in zoneFile \n          //   zoneFile\n          // }\n          \n          // // example.com/auth/grant\n          // let url = `${zoneFile.data.urls.grant}?${qs}`;\n          \n          // TEMPORARY: hardcoded to local auth, NOT using username via chain \n          let authInfo = {\n            local: true\n          };\n          let url = `/auth/grant?${qs}`;\n          console.log('URL:', url);\n          \n          WINDOW.localStorage.setItem('authInfo', JSON.stringify(authInfo));\n          \n          // redirect to /grant page \n          WINDOW.location = url;\n          \n          return false;\n        }\n        render(){\n          return (\n            <div>\n              <button onClick={this.handleSubmit} className=\"button is-primary\">\n                Login, then Grant Permissions\n              </button>\n            </div>\n          )\n        }\n      };\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'types.second.default.react_component',\n        data: mycomponent\n      });\n      \n      \n      \n      \n      function encodeQueryData(data) {\n         const ret = [];\n         for (let d in data)\n           ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(data[d]));\n         return ret.join('&');\n      }\n      \n      async function loadUsernameZonefile(username){\n        // nfkc, stellar details, \n        \n        var horizonPossible = {\n          public: {\n            name: 'PubNet',\n            address: 'https://horizon.stellar.org',\n            network: 'public'\n          },\n          test: {\n            name: 'TestNet',\n            address: 'https://horizon-testnet.stellar.org',\n            network: 'test'\n          }\n        };\n        \n        // load Route\n        // - get rid of \"/html\" or \"/view\"\n        var routeFullPath = username;\n        \n        if(routeFullPath.indexOf('test://') === 0){\n          // ok \n        } else if(routeFullPath.indexOf('test:') === 0){\n          // needs fix \n          routeFullPath = [routeFullPath.slice(0, 5), '//', routeFullPath.slice(5)].join('')\n        }\n        if(routeFullPath.indexOf('second://') === 0){\n          // ok \n        } else if(routeFullPath.indexOf('second:') === 0){\n          // needs fix \n          routeFullPath = [routeFullPath.slice(0, 7), '//', routeFullPath.slice(7)].join('')\n        }\n        \n        \n        if(routeFullPath.indexOf('://') === -1){\n          // Missing, default to public \n          routeFullPath = 'second://' + routeFullPath;\n        }\n        \n        var parser = WINDOW.document.createElement('a');\n        parser.href = routeFullPath; \n          \n        try {\n          var protocol = parser.protocol;\n          switch(protocol){\n            case 'id:':\n            case 'idtest:':\n            case 'test:':\n            case 'second:':\n              parser.protocol = 'http:';\n              break;\n            \n            default:\n              WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n              throw \"invalid protocol\"\n          }\n          \n          var baseIdentity = parser.host;\n          var subname = parser.username || '';\n          var password = parser.password.length ? parser.password : '';\n          var routePath = ''; // zonefile at root! //parser.pathname || '/'; // parser.pathname ? parser.pathname.slice(1) : ''; // OLD removed leading slash! \n          \n          console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n        \n          var stellarServer\n        \n          switch(protocol){\n            case 'id:':\n            case 'second:':\n              StellarSdk.Network.usePublicNetwork();\n              stellarServer = new StellarSdk.Server(horizonPossible['public'].address);\n              break;\n            case 'idtest:':\n            case 'test:':\n            case 'secondtest:':\n              StellarSdk.Network.useTestNetwork();\n              stellarServer = new StellarSdk.Server(horizonPossible['test'].address);\n              break;\n            default:\n              console.error('Invalid protocol');\n              throw \"invalid protocol\"\n          }\n          \n          console.log('stellarServer', stellarServer);\n          \n          // var usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n          var baseIdentity = baseIdentity.normalize('NFKC').toLowerCase();\n          \n          console.log('baseIdentity:', baseIdentity);\n          \n          var usernameSeed = sha256.array(baseIdentity);\n          // NFK\n          console.log('usernameSeed', usernameSeed);\n          \n          var pairForIdentity = StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n          \n          console.log('pairForIdentity', pairForIdentity);\n          \n          \n          let identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n            \n          \n          console.log('identityAccount:', identityAccount);\n          \n          // var lookupPath = subname + '|' + routePath;\n          // if(password){\n          //   lookupPath = password + '|' + subname + '|' + routePath;\n          //   // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n          // }\n          // var lookupPath = '/' + routePath;\n                \n          // route path ALWAYS starts with a slash \n          // - reserving non-slash for zone-like files \n          // if(routePath.length == 0){\n          //   routePath = '/';\n          // }\n          \n          var tmpQuerystring = WINDOW.location.search.substring(1);\n          var vars = tmpQuerystring.split('&');\n          var querystring = {};\n          for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            querystring[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n          }\n          switch(querystring.slash){\n            case 0:\n            case '0':\n            case false:\n            case 'false':\n              routePath = routePath.slice(1);\n              break;\n            default:\n              break;\n          }\n          switch(querystring.root){\n            case 1:\n            case '1':\n            case true:\n            case 'true':\n              routePath = routePath.slice(1);\n              break;\n            default:\n              break;\n          }\n          \n          let lookupPath = baseIdentity + '|' + subname + '|' + password + '|' + routePath;\n          \n          // var lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n           \n          console.log('lookupPath:', lookupPath); \n                           \n          var lookupPathHash = sha256.create().update(lookupPath).hex();\n          \n          console.log('lookupPathHash', lookupPathHash);\n          \n          \n          // get the ipfs value \n          let dataValue = await identityAccount.data({key: lookupPathHash})\n          console.log('dataValue', dataValue);\n          var valueIpfsHash = atob(dataValue.value);\n          \n          \n          console.log('Data Result:', valueIpfsHash);\n          if(!valueIpfsHash){\n            throw 'Missing data result'\n          }\n          \n          \n          // Load IPFS data \n          console.log('valueIpfsHash:', valueIpfsHash);\n          \n          let res = await WINDOW.fetch('https://ipfs.io/ipfs/' + valueIpfsHash);\n          let textResult = await res.text();\n          console.log('textResult:', textResult);\n          \n          // .then(function(res){\n          //   console.log('from IPFS.io:', res);\n          //   return res.text();\n          // })\n          // .then(function(textResult){\n          // })\n          // .catch(function(){\n          //   console.error('Failed loading IPFS hash from ipfs.io');\n          // })\n          \n          let zoneFile = JSON.parse(textResult);\n          \n          console.log('zoneFile:', zoneFile);\n          \n          if(zoneFile.type != 'types.second.default.user.hostfile'){\n            throw \"Invalid host zonefile\"\n          }\n          \n          return zoneFile;\n          \n          \n        }catch(err){\n          // failed finding route data \n          console.error('Failed search', err);\n        }\n        \n        return false;\n      }\n      \n    }catch(err){\n      console.error(err);\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()\n      \n      \n      "
  },
  "blobdata": null,
  "createdAt": "2019-03-02T22:50:02.499Z",
  "updatedAt": "2019-03-02T22:50:02.499Z",
  "nodes": []
}